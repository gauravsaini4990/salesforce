import _Reflect$construct from "@babel/runtime-corejs3/core-js-stable/reflect/construct";
import "core-js/modules/es.array.join";
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _regeneratorRuntime from "@babel/runtime-corejs3/regenerator";
import "regenerator-runtime/runtime";
import _asyncToGenerator from "@babel/runtime-corejs3/helpers/asyncToGenerator";
import _indexOfInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/index-of";
import _Object$keys2 from "@babel/runtime-corejs3/core-js-stable/object/keys";
import _JSON$stringify from "@babel/runtime-corejs3/core-js-stable/json/stringify";
import _toConsumableArray from "@babel/runtime-corejs3/helpers/toConsumableArray";
import _mapInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/map";
import _concatInstanceProperty from "@babel/runtime-corejs3/core-js-stable/instance/concat";
import _classCallCheck from "@babel/runtime-corejs3/helpers/classCallCheck";
import _createClass from "@babel/runtime-corejs3/helpers/createClass";
import _assertThisInitialized from "@babel/runtime-corejs3/helpers/assertThisInitialized";
import _inherits from "@babel/runtime-corejs3/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime-corejs3/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime-corejs3/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(_Reflect$construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @file Manages asynchronous method response cache
 * @author Shinichi Tomita <shinichi.tomita@gmail.com>
 */
import { EventEmitter } from 'events';
/**
 * type def
 */

/**
 * Class for managing cache entry
 *
 * @private
 * @class
 * @constructor
 * @template T
 */
var CacheEntry = /*#__PURE__*/function (_EventEmitter) {
  _inherits(CacheEntry, _EventEmitter);

  var _super = _createSuper(CacheEntry);

  function CacheEntry() {
    var _context;

    var _this;

    _classCallCheck(this, CacheEntry);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, _concatInstanceProperty(_context = [this]).call(_context, args));

    _defineProperty(_assertThisInitialized(_this), "_fetching", false);

    _defineProperty(_assertThisInitialized(_this), "_value", undefined);

    return _this;
  }

  _createClass(CacheEntry, [{
    key: "get",

    /**
     * Get value in the cache entry
     *
     * @param {() => Promise<T>} [callback] - Callback function callbacked the cache entry updated
     * @returns {T|undefined}
     */
    value: function get(callback) {
      if (callback) {
        var cb = callback;
        this.once('value', function (v) {
          return cb(v);
        });

        if (typeof this._value !== 'undefined') {
          this.emit('value', this._value);
        }
      }

      return this._value;
    }
    /**
     * Set value in the cache entry
     */

  }, {
    key: "set",
    value: function set(value) {
      this._value = value;
      this.emit('value', this._value);
    }
    /**
     * Clear cached value
     */

  }, {
    key: "clear",
    value: function clear() {
      this._fetching = false;
      this._value = undefined;
    }
  }]);

  return CacheEntry;
}(EventEmitter);
/**
 * create and return cache key from namespace and serialized arguments.
 * @private
 */


function createCacheKey(namespace, args) {
  var _context2, _context3;

  return _concatInstanceProperty(_context2 = "".concat(namespace || '', "(")).call(_context2, _mapInstanceProperty(_context3 = _toConsumableArray(args)).call(_context3, function (a) {
    return _JSON$stringify(a);
  }).join(','), ")");
}

function generateKeyString(options, scope, args) {
  return typeof options.key === 'string' ? options.key : typeof options.key === 'function' ? options.key.apply(scope, args) : createCacheKey(options.namespace, args);
}
/**
 * Caching manager for async methods
 *
 * @class
 * @constructor
 */


export var Cache = /*#__PURE__*/function () {
  function Cache() {
    _classCallCheck(this, Cache);

    _defineProperty(this, "_entries", {});
  }

  _createClass(Cache, [{
    key: "get",

    /**
     * retrive cache entry, or create if not exists.
     *
     * @param {String} [key] - Key of cache entry
     * @returns {CacheEntry}
     */
    value: function get(key) {
      if (this._entries[key]) {
        return this._entries[key];
      }

      var entry = new CacheEntry();
      this._entries[key] = entry;
      return entry;
    }
    /**
     * clear cache entries prefix matching given key
     */

  }, {
    key: "clear",
    value: function clear(key) {
      for (var _i = 0, _Object$keys = _Object$keys2(this._entries); _i < _Object$keys.length; _i++) {
        var k = _Object$keys[_i];

        if (!key || _indexOfInstanceProperty(k).call(k, key) === 0) {
          this._entries[k].clear();
        }
      }
    }
    /**
     * Enable caching for async call fn to lookup the response cache first,
     * then invoke original if no cached value.
     */

  }, {
    key: "createCachedFunction",
    value: function createCachedFunction(fn, scope) {
      var _this2 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        strategy: 'NOCACHE'
      };
      var strategy = options.strategy;

      var $fn = function $fn() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var key = generateKeyString(options, scope, args);

        var entry = _this2.get(key);

        var executeFetch = /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
            var result;
            return _regeneratorRuntime.wrap(function _callee$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    entry._fetching = true;
                    _context4.prev = 1;
                    _context4.next = 4;
                    return fn.apply(scope || _this2, args);

                  case 4:
                    result = _context4.sent;
                    entry.set({
                      error: undefined,
                      result: result
                    });
                    return _context4.abrupt("return", result);

                  case 9:
                    _context4.prev = 9;
                    _context4.t0 = _context4["catch"](1);
                    entry.set({
                      error: _context4.t0,
                      result: undefined
                    });
                    throw _context4.t0;

                  case 13:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee, null, [[1, 9]]);
          }));

          return function executeFetch() {
            return _ref.apply(this, arguments);
          };
        }();

        var value;

        switch (strategy) {
          case 'IMMEDIATE':
            value = entry.get();

            if (!value) {
              throw new Error('Function call result is not cached yet.');
            }

            if (value.error) {
              throw value.error;
            }

            return value.result;

          case 'HIT':
            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
              return _regeneratorRuntime.wrap(function _callee2$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      if (entry._fetching) {
                        _context5.next = 3;
                        break;
                      }

                      _context5.next = 3;
                      return executeFetch();

                    case 3:
                      return _context5.abrupt("return", new _Promise(function (resolve, reject) {
                        entry.get(function (_ref3) {
                          var error = _ref3.error,
                              result = _ref3.result;
                          if (error) reject(error);else resolve(result);
                        });
                      }));

                    case 4:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee2);
            }))();

          case 'NOCACHE':
          default:
            return executeFetch();
        }
      };

      $fn.clear = function () {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var key = generateKeyString(options, scope, args);

        _this2.clear(key);
      };

      return $fn;
    }
  }]);

  return Cache;
}();
export default Cache;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jYWNoZS50cyJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJDYWNoZUVudHJ5IiwidW5kZWZpbmVkIiwiY2FsbGJhY2siLCJjYiIsIm9uY2UiLCJ2IiwiX3ZhbHVlIiwiZW1pdCIsInZhbHVlIiwiX2ZldGNoaW5nIiwiY3JlYXRlQ2FjaGVLZXkiLCJuYW1lc3BhY2UiLCJhcmdzIiwiYSIsImpvaW4iLCJnZW5lcmF0ZUtleVN0cmluZyIsIm9wdGlvbnMiLCJzY29wZSIsImtleSIsImFwcGx5IiwiQ2FjaGUiLCJfZW50cmllcyIsImVudHJ5IiwiayIsImNsZWFyIiwiZm4iLCJzdHJhdGVneSIsIiRmbiIsImdldCIsImV4ZWN1dGVGZXRjaCIsInJlc3VsdCIsInNldCIsImVycm9yIiwiRXJyb3IiLCJyZXNvbHZlIiwicmVqZWN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNBLFlBQVQsUUFBNkIsUUFBN0I7QUFFQTtBQUNBO0FBQ0E7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNNQyxVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0VBQ2lCLEs7OzZEQUNVQyxTOzs7Ozs7OztBQUUvQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7d0JBQ01DLFEsRUFBZ0Q7QUFDbEQsVUFBSUEsUUFBSixFQUFjO0FBQ1osWUFBTUMsRUFBRSxHQUFHRCxRQUFYO0FBQ0EsYUFBS0UsSUFBTCxDQUFVLE9BQVYsRUFBbUIsVUFBQ0MsQ0FBRDtBQUFBLGlCQUFVRixFQUFFLENBQUNFLENBQUQsQ0FBWjtBQUFBLFNBQW5COztBQUNBLFlBQUksT0FBTyxLQUFLQyxNQUFaLEtBQXVCLFdBQTNCLEVBQXdDO0FBQ3RDLGVBQUtDLElBQUwsQ0FBVSxPQUFWLEVBQW1CLEtBQUtELE1BQXhCO0FBQ0Q7QUFDRjs7QUFDRCxhQUFPLEtBQUtBLE1BQVo7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7Ozt3QkFDTUUsSyxFQUFzQjtBQUN4QixXQUFLRixNQUFMLEdBQWNFLEtBQWQ7QUFDQSxXQUFLRCxJQUFMLENBQVUsT0FBVixFQUFtQixLQUFLRCxNQUF4QjtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7OzRCQUNVO0FBQ04sV0FBS0csU0FBTCxHQUFpQixLQUFqQjtBQUNBLFdBQUtILE1BQUwsR0FBY0wsU0FBZDtBQUNEOzs7O0VBbkN5QkYsWTtBQXNDNUI7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNXLGNBQVQsQ0FBd0JDLFNBQXhCLEVBQWtEQyxJQUFsRCxFQUF1RTtBQUFBOztBQUNyRSx1REFBVUQsU0FBUyxJQUFJLEVBQXZCLHdCQUE2QixvREFBSUMsSUFBSixtQkFDdEIsVUFBQ0MsQ0FBRDtBQUFBLFdBQU8sZ0JBQWVBLENBQWYsQ0FBUDtBQUFBLEdBRHNCLEVBRTFCQyxJQUYwQixDQUVyQixHQUZxQixDQUE3QjtBQUdEOztBQUVELFNBQVNDLGlCQUFULENBQ0VDLE9BREYsRUFFRUMsS0FGRixFQUdFTCxJQUhGLEVBSVU7QUFDUixTQUFPLE9BQU9JLE9BQU8sQ0FBQ0UsR0FBZixLQUF1QixRQUF2QixHQUNIRixPQUFPLENBQUNFLEdBREwsR0FFSCxPQUFPRixPQUFPLENBQUNFLEdBQWYsS0FBdUIsVUFBdkIsR0FDQUYsT0FBTyxDQUFDRSxHQUFSLENBQVlDLEtBQVosQ0FBa0JGLEtBQWxCLEVBQXlCTCxJQUF6QixDQURBLEdBRUFGLGNBQWMsQ0FBQ00sT0FBTyxDQUFDTCxTQUFULEVBQW9CQyxJQUFwQixDQUpsQjtBQUtEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFhUSxLQUFiO0FBQUE7QUFBQTs7QUFBQSxzQ0FDeUQsRUFEekQ7QUFBQTs7QUFBQTtBQUFBOztBQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBLHdCQVNNRixHQVROLEVBU21CO0FBQ2YsVUFBSSxLQUFLRyxRQUFMLENBQWNILEdBQWQsQ0FBSixFQUF3QjtBQUN0QixlQUFPLEtBQUtHLFFBQUwsQ0FBY0gsR0FBZCxDQUFQO0FBQ0Q7O0FBQ0QsVUFBTUksS0FBSyxHQUFHLElBQUl0QixVQUFKLEVBQWQ7QUFDQSxXQUFLcUIsUUFBTCxDQUFjSCxHQUFkLElBQXFCSSxLQUFyQjtBQUNBLGFBQU9BLEtBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7QUFwQkE7QUFBQTtBQUFBLDBCQXFCUUosR0FyQlIsRUFxQnNCO0FBQ2xCLHNDQUFnQixjQUFZLEtBQUtHLFFBQWpCLENBQWhCLGtDQUE0QztBQUF2QyxZQUFNRSxDQUFDLG1CQUFQOztBQUNILFlBQUksQ0FBQ0wsR0FBRCxJQUFRLHlCQUFBSyxDQUFDLE1BQUQsQ0FBQUEsQ0FBQyxFQUFTTCxHQUFULENBQUQsS0FBbUIsQ0FBL0IsRUFBa0M7QUFDaEMsZUFBS0csUUFBTCxDQUFjRSxDQUFkLEVBQWlCQyxLQUFqQjtBQUNEO0FBQ0Y7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBOztBQWhDQTtBQUFBO0FBQUEseUNBa0NJQyxFQWxDSixFQW1DSVIsS0FuQ0osRUFxQ3dCO0FBQUE7O0FBQUEsVUFEcEJELE9BQ29CLHVFQURNO0FBQUVVLFFBQUFBLFFBQVEsRUFBRTtBQUFaLE9BQ047QUFDcEIsVUFBTUEsUUFBUSxHQUFHVixPQUFPLENBQUNVLFFBQXpCOztBQUNBLFVBQU1DLEdBQVEsR0FBRyxTQUFYQSxHQUFXLEdBQW9CO0FBQUEsMkNBQWhCZixJQUFnQjtBQUFoQkEsVUFBQUEsSUFBZ0I7QUFBQTs7QUFDbkMsWUFBTU0sR0FBRyxHQUFHSCxpQkFBaUIsQ0FBQ0MsT0FBRCxFQUFVQyxLQUFWLEVBQWlCTCxJQUFqQixDQUE3Qjs7QUFDQSxZQUFNVSxLQUFLLEdBQUcsTUFBSSxDQUFDTSxHQUFMLENBQVNWLEdBQVQsQ0FBZDs7QUFDQSxZQUFNVyxZQUFZO0FBQUEsOEVBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ25CUCxvQkFBQUEsS0FBSyxDQUFDYixTQUFOLEdBQWtCLElBQWxCO0FBRG1CO0FBQUE7QUFBQSwyQkFHSWdCLEVBQUUsQ0FBQ04sS0FBSCxDQUFTRixLQUFLLElBQUksTUFBbEIsRUFBd0JMLElBQXhCLENBSEo7O0FBQUE7QUFHWGtCLG9CQUFBQSxNQUhXO0FBSWpCUixvQkFBQUEsS0FBSyxDQUFDUyxHQUFOLENBQVU7QUFBRUMsc0JBQUFBLEtBQUssRUFBRS9CLFNBQVQ7QUFBb0I2QixzQkFBQUEsTUFBTSxFQUFOQTtBQUFwQixxQkFBVjtBQUppQixzREFLVkEsTUFMVTs7QUFBQTtBQUFBO0FBQUE7QUFPakJSLG9CQUFBQSxLQUFLLENBQUNTLEdBQU4sQ0FBVTtBQUFFQyxzQkFBQUEsS0FBSyxjQUFQO0FBQVNGLHNCQUFBQSxNQUFNLEVBQUU3QjtBQUFqQixxQkFBVjtBQVBpQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFIOztBQUFBLDBCQUFaNEIsWUFBWTtBQUFBO0FBQUE7QUFBQSxXQUFsQjs7QUFXQSxZQUFJckIsS0FBSjs7QUFDQSxnQkFBUWtCLFFBQVI7QUFDRSxlQUFLLFdBQUw7QUFDRWxCLFlBQUFBLEtBQUssR0FBR2MsS0FBSyxDQUFDTSxHQUFOLEVBQVI7O0FBQ0EsZ0JBQUksQ0FBQ3BCLEtBQUwsRUFBWTtBQUNWLG9CQUFNLElBQUl5QixLQUFKLENBQVUseUNBQVYsQ0FBTjtBQUNEOztBQUNELGdCQUFJekIsS0FBSyxDQUFDd0IsS0FBVixFQUFpQjtBQUNmLG9CQUFNeEIsS0FBSyxDQUFDd0IsS0FBWjtBQUNEOztBQUNELG1CQUFPeEIsS0FBSyxDQUFDc0IsTUFBYjs7QUFDRixlQUFLLEtBQUw7QUFDRSxtQkFBTyx5REFBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMEJBQ0RSLEtBQUssQ0FBQ2IsU0FETDtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLDZCQUdFb0IsWUFBWSxFQUhkOztBQUFBO0FBQUEsd0RBS0MsYUFBWSxVQUFDSyxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDdENiLHdCQUFBQSxLQUFLLENBQUNNLEdBQU4sQ0FBVSxpQkFBdUI7QUFBQSw4QkFBcEJJLEtBQW9CLFNBQXBCQSxLQUFvQjtBQUFBLDhCQUFiRixNQUFhLFNBQWJBLE1BQWE7QUFDL0IsOEJBQUlFLEtBQUosRUFBV0csTUFBTSxDQUFDSCxLQUFELENBQU4sQ0FBWCxLQUNLRSxPQUFPLENBQUNKLE1BQUQsQ0FBUDtBQUNOLHlCQUhEO0FBSUQsdUJBTE0sQ0FMRDs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUFELElBQVA7O0FBWUYsZUFBSyxTQUFMO0FBQ0E7QUFDRSxtQkFBT0QsWUFBWSxFQUFuQjtBQXpCSjtBQTJCRCxPQTFDRDs7QUEyQ0FGLE1BQUFBLEdBQUcsQ0FBQ0gsS0FBSixHQUFZLFlBQW9CO0FBQUEsMkNBQWhCWixJQUFnQjtBQUFoQkEsVUFBQUEsSUFBZ0I7QUFBQTs7QUFDOUIsWUFBTU0sR0FBRyxHQUFHSCxpQkFBaUIsQ0FBQ0MsT0FBRCxFQUFVQyxLQUFWLEVBQWlCTCxJQUFqQixDQUE3Qjs7QUFDQSxRQUFBLE1BQUksQ0FBQ1ksS0FBTCxDQUFXTixHQUFYO0FBQ0QsT0FIRDs7QUFJQSxhQUFPUyxHQUFQO0FBQ0Q7QUF2Rkg7O0FBQUE7QUFBQTtBQTBGQSxlQUFlUCxLQUFmIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIGFzeW5jaHJvbm91cyBtZXRob2QgcmVzcG9uc2UgY2FjaGVcbiAqIEBhdXRob3IgU2hpbmljaGkgVG9taXRhIDxzaGluaWNoaS50b21pdGFAZ21haWwuY29tPlxuICovXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuXG4vKipcbiAqIHR5cGUgZGVmXG4gKi9cbmV4cG9ydCB0eXBlIENhY2hpbmdPcHRpb25zID0ge1xuICBrZXk/OiBzdHJpbmcgfCAoKC4uLmFyZ3M6IGFueVtdKSA9PiBzdHJpbmcpO1xuICBuYW1lc3BhY2U/OiBzdHJpbmc7XG4gIHN0cmF0ZWd5OiAnTk9DQUNIRScgfCAnSElUJyB8ICdJTU1FRElBVEUnO1xufTtcblxudHlwZSBDYWNoZVZhbHVlPFQ+ID0ge1xuICBlcnJvcj86IEVycm9yO1xuICByZXN1bHQ6IFQ7XG59O1xuXG5leHBvcnQgdHlwZSBDYWNoZWRGdW5jdGlvbjxGbj4gPSBGbiAmIHsgY2xlYXI6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCB9O1xuXG4vKipcbiAqIENsYXNzIGZvciBtYW5hZ2luZyBjYWNoZSBlbnRyeVxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRlbXBsYXRlIFRcbiAqL1xuY2xhc3MgQ2FjaGVFbnRyeTxUPiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIF9mZXRjaGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICBfdmFsdWU6IENhY2hlVmFsdWU8VD4gfCB2b2lkID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBHZXQgdmFsdWUgaW4gdGhlIGNhY2hlIGVudHJ5XG4gICAqXG4gICAqIEBwYXJhbSB7KCkgPT4gUHJvbWlzZTxUPn0gW2NhbGxiYWNrXSAtIENhbGxiYWNrIGZ1bmN0aW9uIGNhbGxiYWNrZWQgdGhlIGNhY2hlIGVudHJ5IHVwZGF0ZWRcbiAgICogQHJldHVybnMge1R8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0KGNhbGxiYWNrPzogKHY6IFQpID0+IGFueSk6IENhY2hlVmFsdWU8VD4gfCB2b2lkIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLm9uY2UoJ3ZhbHVlJywgKHY6IFQpID0+IGNiKHYpKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuZW1pdCgndmFsdWUnLCB0aGlzLl92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdmFsdWUgaW4gdGhlIGNhY2hlIGVudHJ5XG4gICAqL1xuICBzZXQodmFsdWU6IENhY2hlVmFsdWU8VD4pIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuZW1pdCgndmFsdWUnLCB0aGlzLl92YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgY2FjaGVkIHZhbHVlXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLl9mZXRjaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogY3JlYXRlIGFuZCByZXR1cm4gY2FjaGUga2V5IGZyb20gbmFtZXNwYWNlIGFuZCBzZXJpYWxpemVkIGFyZ3VtZW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlS2V5KG5hbWVzcGFjZTogc3RyaW5nIHwgdm9pZCwgYXJnczogYW55W10pOiBzdHJpbmcge1xuICByZXR1cm4gYCR7bmFtZXNwYWNlIHx8ICcnfSgke1suLi5hcmdzXVxuICAgIC5tYXAoKGEpID0+IEpTT04uc3RyaW5naWZ5KGEpKVxuICAgIC5qb2luKCcsJyl9KWA7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5U3RyaW5nKFxuICBvcHRpb25zOiBDYWNoaW5nT3B0aW9ucyxcbiAgc2NvcGU6IGFueSxcbiAgYXJnczogYW55W10sXG4pOiBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIG9wdGlvbnMua2V5ID09PSAnc3RyaW5nJ1xuICAgID8gb3B0aW9ucy5rZXlcbiAgICA6IHR5cGVvZiBvcHRpb25zLmtleSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gb3B0aW9ucy5rZXkuYXBwbHkoc2NvcGUsIGFyZ3MpXG4gICAgOiBjcmVhdGVDYWNoZUtleShvcHRpb25zLm5hbWVzcGFjZSwgYXJncyk7XG59XG5cbi8qKlxuICogQ2FjaGluZyBtYW5hZ2VyIGZvciBhc3luYyBtZXRob2RzXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGNsYXNzIENhY2hlIHtcbiAgcHJpdmF0ZSBfZW50cmllczogeyBba2V5OiBzdHJpbmddOiBDYWNoZUVudHJ5PGFueT4gfSA9IHt9O1xuXG4gIC8qKlxuICAgKiByZXRyaXZlIGNhY2hlIGVudHJ5LCBvciBjcmVhdGUgaWYgbm90IGV4aXN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldIC0gS2V5IG9mIGNhY2hlIGVudHJ5XG4gICAqIEByZXR1cm5zIHtDYWNoZUVudHJ5fVxuICAgKi9cbiAgZ2V0KGtleTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX2VudHJpZXNba2V5XSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VudHJpZXNba2V5XTtcbiAgICB9XG4gICAgY29uc3QgZW50cnkgPSBuZXcgQ2FjaGVFbnRyeSgpO1xuICAgIHRoaXMuX2VudHJpZXNba2V5XSA9IGVudHJ5O1xuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjbGVhciBjYWNoZSBlbnRyaWVzIHByZWZpeCBtYXRjaGluZyBnaXZlbiBrZXlcbiAgICovXG4gIGNsZWFyKGtleT86IHN0cmluZykge1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh0aGlzLl9lbnRyaWVzKSkge1xuICAgICAgaWYgKCFrZXkgfHwgay5pbmRleE9mKGtleSkgPT09IDApIHtcbiAgICAgICAgdGhpcy5fZW50cmllc1trXS5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgY2FjaGluZyBmb3IgYXN5bmMgY2FsbCBmbiB0byBsb29rdXAgdGhlIHJlc3BvbnNlIGNhY2hlIGZpcnN0LFxuICAgKiB0aGVuIGludm9rZSBvcmlnaW5hbCBpZiBubyBjYWNoZWQgdmFsdWUuXG4gICAqL1xuICBjcmVhdGVDYWNoZWRGdW5jdGlvbjxGbiBleHRlbmRzIEZ1bmN0aW9uPihcbiAgICBmbjogRm4sXG4gICAgc2NvcGU6IGFueSxcbiAgICBvcHRpb25zOiBDYWNoaW5nT3B0aW9ucyA9IHsgc3RyYXRlZ3k6ICdOT0NBQ0hFJyB9LFxuICApOiBDYWNoZWRGdW5jdGlvbjxGbj4ge1xuICAgIGNvbnN0IHN0cmF0ZWd5ID0gb3B0aW9ucy5zdHJhdGVneTtcbiAgICBjb25zdCAkZm46IGFueSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gZ2VuZXJhdGVLZXlTdHJpbmcob3B0aW9ucywgc2NvcGUsIGFyZ3MpO1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmdldChrZXkpO1xuICAgICAgY29uc3QgZXhlY3V0ZUZldGNoID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBlbnRyeS5fZmV0Y2hpbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuLmFwcGx5KHNjb3BlIHx8IHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIGVudHJ5LnNldCh7IGVycm9yOiB1bmRlZmluZWQsIHJlc3VsdCB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGVudHJ5LnNldCh7IGVycm9yLCByZXN1bHQ6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSAnSU1NRURJQVRFJzpcbiAgICAgICAgICB2YWx1ZSA9IGVudHJ5LmdldCgpO1xuICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbCByZXN1bHQgaXMgbm90IGNhY2hlZCB5ZXQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZS5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdmFsdWUuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXN1bHQ7XG4gICAgICAgIGNhc2UgJ0hJVCc6XG4gICAgICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVudHJ5Ll9mZXRjaGluZykge1xuICAgICAgICAgICAgICAvLyBvbmx5IHdoZW4gbm8gb3RoZXIgY2xpZW50IGlzIGNhbGxpbmcgZnVuY3Rpb25cbiAgICAgICAgICAgICAgYXdhaXQgZXhlY3V0ZUZldGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICBlbnRyeS5nZXQoKHsgZXJyb3IsIHJlc3VsdCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIGNhc2UgJ05PQ0FDSEUnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBleGVjdXRlRmV0Y2goKTtcbiAgICAgIH1cbiAgICB9O1xuICAgICRmbi5jbGVhciA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gZ2VuZXJhdGVLZXlTdHJpbmcob3B0aW9ucywgc2NvcGUsIGFyZ3MpO1xuICAgICAgdGhpcy5jbGVhcihrZXkpO1xuICAgIH07XG4gICAgcmV0dXJuICRmbiBhcyBDYWNoZWRGdW5jdGlvbjxGbj47XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FjaGU7XG4iXX0=