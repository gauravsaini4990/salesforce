"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const fileWriter_1 = require("../../../lib/helpers/fileWriter");
const validationUtil_1 = require("../../../lib/helpers/validationUtil");
const templates_1 = require("../../../lib/templates/templates");
// Initialize Messages with the current plugin directory
core_1.Messages.importMessagesDirectory(__dirname);
// Load the specific messages for this file. Messages from @salesforce/command, @salesforce/core,
// or any library that is using the messages framework can also be loaded this way.
const messages = core_1.Messages.loadMessages('@salesforce/plugin-custom-metadata', 'createType');
class Create extends command_1.SfdxCommand {
    async run() {
        const typename = this.flags.typename; // this should become the new file name
        const label = this.flags.label || this.flags.typename.replace('__mdt', ''); // If a label is not provided default using the dev name. trim __mdt out
        const pluralLabel = this.flags.plurallabel || label;
        const visibility = this.flags.visibility || 'Public';
        const dir = this.flags.outputdir || '';
        const templates = new templates_1.Templates();
        const fileWriter = new fileWriter_1.FileWriter();
        let saveResults;
        const validator = new validationUtil_1.ValidationUtil();
        if (!validator.validateMetadataTypeName(typename)) {
            throw new core_1.SfdxError(messages.getMessage('errorNotValidAPIName', [typename]));
        }
        if (!validator.validateLessThanForty(label)) {
            throw new core_1.SfdxError(messages.getMessage('errorNotValidLabelName', [label]));
        }
        if (!validator.validateLessThanForty(pluralLabel)) {
            throw new core_1.SfdxError(messages.getMessage('errorNotValidPluralLabelName', [pluralLabel]));
        }
        const objectXML = templates.createObjectXML({ label, pluralLabel }, visibility);
        saveResults = await fileWriter.writeTypeFile(core_1.fs, dir, typename, objectXML);
        this.ux.log(messages.getMessage('targetDirectory', [saveResults.dir]));
        this.ux.log(messages.getMessage(saveResults.updated ? 'fileUpdate' : 'fileCreated', [
            saveResults.fileName,
        ]));
        return {
            typename,
            label,
            pluralLabel,
            visibility,
        };
    }
}
exports.default = Create;
Create.description = messages.getMessage('commandDescription');
Create.longDescription = messages.getMessage('commandLongDescription');
Create.examples = [
    messages.getMessage('exampleCaption1'),
    '    $ sfdx force:cmdt:create --typename MyCustomType',
    messages.getMessage('exampleCaption2'),
    '    $ sfdx force:cmdt:create --typename MyCustomType --label "' +
        messages.getMessage('labelFlagExample') +
        '" ' +
        '--plurallabel "' +
        messages.getMessage('plurallabelFlagExample') +
        '" --visibility Protected',
];
Create.args = [{ name: 'file' }];
Create.flagsConfig = {
    typename: command_1.flags.string({
        char: 'n',
        description: messages.getMessage('nameFlagDescription'),
        longDescription: messages.getMessage('nameFlagLongDescription'),
        required: true,
    }),
    label: command_1.flags.string({
        char: 'l',
        description: messages.getMessage('labelFlagDescription'),
        longDescription: messages.getMessage('labelFlagLongDescription'),
    }),
    plurallabel: command_1.flags.string({
        char: 'p',
        description: messages.getMessage('plurallabelFlagDescription'),
        longDescription: messages.getMessage('plurallabelFlagLongDescription'),
    }),
    visibility: command_1.flags.enum({
        char: 'v',
        description: messages.getMessage('visibilityFlagDescription'),
        longDescription: messages.getMessage('visibilityFlagLongDescription'),
        options: ['PackageProtected', 'Protected', 'Public'],
        default: 'Public',
    }),
    outputdir: command_1.flags.directory({
        char: 'd',
        description: messages.getMessage('outputDirectoryFlagDescription'),
        longDescription: messages.getMessage('outputDirectoryFlagLongDescription'),
    }),
};
// Set this to true if your command requires a project workspace; 'requiresProject' is false by default
Create.requiresProject = true;
//# sourceMappingURL=create.js.map