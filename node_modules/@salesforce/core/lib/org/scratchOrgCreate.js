"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scratchOrgCreate = exports.scratchOrgResume = exports.DEFAULT_STREAM_TIMEOUT_MINUTES = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const messages_1 = require("../messages");
const logger_1 = require("../logger");
const configAggregator_1 = require("../config/configAggregator");
const sfProject_1 = require("../sfProject");
const globalInfo_1 = require("../globalInfo");
const org_1 = require("./org");
const scratchOrgInfoApi_1 = require("./scratchOrgInfoApi");
const scratchOrgSettingsGenerator_1 = require("./scratchOrgSettingsGenerator");
const scratchOrgInfoGenerator_1 = require("./scratchOrgInfoGenerator");
const authInfo_1 = require("./authInfo");
const scratchOrgLifecycleEvents_1 = require("./scratchOrgLifecycleEvents");
const scratchOrgCache_1 = require("./scratchOrgCache");
const scratchOrgErrorCodes_1 = require("./scratchOrgErrorCodes");
messages_1.Messages.importMessagesDirectory(__dirname);
const messages = messages_1.Messages.load('@salesforce/core', 'scratchOrgCreate', [
    'SourceStatusResetFailureError',
    'DurationDaysValidationMaxError',
    'DurationDaysValidationMinError',
    'RetryNotIntError',
    'WaitValidationMaxError',
    'DurationDaysNotIntError',
    'NoScratchOrgInfoError',
    'ScratchOrgDeletedError',
    'StillInProgressError',
    'CacheMissError',
    'action.StillInProgress',
]);
exports.DEFAULT_STREAM_TIMEOUT_MINUTES = 6;
const validateDuration = (durationDays) => {
    const min = 1;
    const max = 30;
    if (Number.isInteger(durationDays)) {
        if (durationDays < min) {
            throw messages.createError('DurationDaysValidationMinError', [min, durationDays]);
        }
        if (durationDays > max) {
            throw messages.createError('DurationDaysValidationMaxError', [max, durationDays]);
        }
        return;
    }
    throw messages.createError('DurationDaysNotIntError');
};
const validateRetry = (retry) => {
    if (!Number.isInteger(retry)) {
        throw messages.createError('RetryNotIntError');
    }
};
const scratchOrgResume = async (jobId) => {
    var _a, _b, _c;
    const [logger, cache] = await Promise.all([
        logger_1.Logger.child('scratchOrgResume'),
        scratchOrgCache_1.ScratchOrgCache.create(),
        (0, scratchOrgLifecycleEvents_1.emit)({ stage: 'send request' }),
    ]);
    logger.debug(`resuming scratch org creation for jobId: ${jobId}`);
    if (!cache.has(jobId)) {
        throw messages.createError('CacheMissError', [jobId]);
    }
    const { hubUsername, apiVersion, clientSecret, signupTargetLoginUrlConfig, definitionjson, alias, setDefault } = cache.get(jobId);
    const hubOrg = await org_1.Org.create({ aliasOrUsername: hubUsername });
    const soi = await (0, scratchOrgInfoApi_1.queryScratchOrgInfo)(hubOrg, jobId);
    await (0, scratchOrgErrorCodes_1.validateScratchOrgInfoForResume)({ jobId, scratchOrgInfo: soi, cache, hubUsername });
    // At this point, the scratch org is "good".
    // Some hubs have all the usernames set to `null`
    const username = (_a = soi.Username) !== null && _a !== void 0 ? _a : soi.SignupUsername;
    // re-auth only if the org isn't in GlobalInfo
    const globalInfo = await globalInfo_1.GlobalInfo.getInstance();
    const scratchOrgAuthInfo = globalInfo.orgs.has(username)
        ? await authInfo_1.AuthInfo.create({
            username,
        })
        : await (0, scratchOrgInfoApi_1.authorizeScratchOrg)({
            scratchOrgInfoComplete: soi,
            hubOrg,
            clientSecret,
            signupTargetLoginUrlConfig,
            retry: 0,
        });
    const scratchOrg = await org_1.Org.create({ aliasOrUsername: username });
    await (0, scratchOrgLifecycleEvents_1.emit)({ stage: 'deploy settings', scratchOrgInfo: soi });
    const settingsGenerator = new scratchOrgSettingsGenerator_1.default();
    settingsGenerator.extract({ ...soi, ...definitionjson });
    const [authInfo] = await Promise.all([
        (0, scratchOrgInfoApi_1.resolveUrl)(scratchOrgAuthInfo),
        (0, scratchOrgInfoApi_1.deploySettings)(scratchOrg, settingsGenerator, (_b = apiVersion !== null && apiVersion !== void 0 ? apiVersion : new configAggregator_1.ConfigAggregator().getPropertyValue('apiVersion')) !== null && _b !== void 0 ? _b : (await scratchOrg.retrieveMaxApiVersion())),
    ]);
    await scratchOrgAuthInfo.handleAliasAndDefaultSettings({
        alias,
        setDefault: setDefault !== null && setDefault !== void 0 ? setDefault : false,
        setDefaultDevHub: false,
    });
    cache.unset((_c = soi.Id) !== null && _c !== void 0 ? _c : jobId);
    const authFields = authInfo.getFields();
    await Promise.all([(0, scratchOrgLifecycleEvents_1.emit)({ stage: 'done', scratchOrgInfo: soi }), cache.write(), (0, scratchOrgLifecycleEvents_1.emitPostOrgCreate)(authFields)]);
    return {
        username,
        scratchOrgInfo: soi,
        authInfo,
        authFields,
        warnings: [],
    };
};
exports.scratchOrgResume = scratchOrgResume;
const scratchOrgCreate = async (options) => {
    var _a, _b, _c;
    const logger = await logger_1.Logger.child('scratchOrgCreate');
    logger.debug('scratchOrgCreate');
    await (0, scratchOrgLifecycleEvents_1.emit)({ stage: 'prepare request' });
    const { hubOrg, connectedAppConsumerKey, durationDays = 1, nonamespace, noancestors, wait = kit_1.Duration.minutes(exports.DEFAULT_STREAM_TIMEOUT_MINUTES), retry = 0, apiversion, definitionjson, definitionfile, orgConfig, clientSecret = undefined, alias, setDefault = false, } = options;
    validateDuration(durationDays);
    validateRetry(retry);
    const { scratchOrgInfoPayload, ignoreAncestorIds, warnings } = await (0, scratchOrgInfoGenerator_1.getScratchOrgInfoPayload)({
        definitionjson,
        definitionfile,
        connectedAppConsumerKey,
        durationDays,
        nonamespace,
        noancestors,
        orgConfig,
    });
    const scratchOrgInfo = await (0, scratchOrgInfoGenerator_1.generateScratchOrgInfo)({
        hubOrg,
        scratchOrgInfoPayload,
        nonamespace,
        ignoreAncestorIds,
    });
    // gets the scratch org settings (will use in both signup paths AND to deploy the settings)
    const settingsGenerator = new scratchOrgSettingsGenerator_1.default();
    const settings = await settingsGenerator.extract(scratchOrgInfo);
    logger.debug(`the scratch org def file has settings: ${settingsGenerator.hasSettings()}`);
    const [scratchOrgInfoRequestResult, signupTargetLoginUrlConfig] = await Promise.all([
        // creates the scratch org info in the devhub
        (0, scratchOrgInfoApi_1.requestScratchOrgCreation)(hubOrg, scratchOrgInfo, settingsGenerator),
        getSignupTargetLoginUrl(),
    ]);
    const scratchOrgInfoId = (0, ts_types_1.ensureString)((0, ts_types_1.getString)(scratchOrgInfoRequestResult, 'id'));
    const cache = await scratchOrgCache_1.ScratchOrgCache.create();
    cache.set(scratchOrgInfoId, {
        hubUsername: hubOrg.getUsername(),
        hubBaseUrl: (_a = hubOrg.getField(org_1.Org.Fields.INSTANCE_URL)) === null || _a === void 0 ? void 0 : _a.toString(),
        definitionjson: { ...(definitionjson ? JSON.parse(definitionjson) : {}), ...orgConfig, ...settings },
        clientSecret,
        alias,
        setDefault,
    });
    await cache.write();
    logger.debug(`scratch org has recordId ${scratchOrgInfoId}`);
    // this is where we stop--no polling
    if (wait.minutes === 0) {
        const soi = await (0, scratchOrgInfoApi_1.queryScratchOrgInfo)(hubOrg, scratchOrgInfoId);
        return {
            username: soi.SignupUsername,
            warnings: [],
            scratchOrgInfo: soi,
        };
    }
    const soi = await (0, scratchOrgInfoApi_1.pollForScratchOrgInfo)(hubOrg, scratchOrgInfoId, wait);
    const scratchOrgAuthInfo = await (0, scratchOrgInfoApi_1.authorizeScratchOrg)({
        scratchOrgInfoComplete: soi,
        hubOrg,
        clientSecret,
        signupTargetLoginUrlConfig,
        retry: retry || 0,
    });
    // we'll need this scratch org connection later;
    const scratchOrg = await org_1.Org.create({
        aliasOrUsername: (_b = soi.Username) !== null && _b !== void 0 ? _b : soi.SignupUsername,
    });
    const username = scratchOrg.getUsername();
    logger.debug(`scratch org username ${username}`);
    await (0, scratchOrgLifecycleEvents_1.emit)({ stage: 'deploy settings', scratchOrgInfo: soi });
    const [authInfo] = await Promise.all([
        (0, scratchOrgInfoApi_1.resolveUrl)(scratchOrgAuthInfo),
        (0, scratchOrgInfoApi_1.deploySettings)(scratchOrg, settingsGenerator, (_c = apiversion !== null && apiversion !== void 0 ? apiversion : new configAggregator_1.ConfigAggregator().getPropertyValue('org-api-version')) !== null && _c !== void 0 ? _c : (await scratchOrg.retrieveMaxApiVersion())),
    ]);
    await scratchOrgAuthInfo.handleAliasAndDefaultSettings({
        alias,
        setDefault,
        setDefaultDevHub: false,
    });
    cache.unset(scratchOrgInfoId);
    const authFields = authInfo.getFields();
    await Promise.all([(0, scratchOrgLifecycleEvents_1.emit)({ stage: 'done', scratchOrgInfo: soi }), cache.write(), (0, scratchOrgLifecycleEvents_1.emitPostOrgCreate)(authFields)]);
    return {
        username,
        scratchOrgInfo: soi,
        authInfo,
        authFields: authInfo === null || authInfo === void 0 ? void 0 : authInfo.getFields(),
        warnings,
    };
};
exports.scratchOrgCreate = scratchOrgCreate;
const getSignupTargetLoginUrl = async () => {
    try {
        const project = await sfProject_1.SfProject.resolve();
        const projectJson = await project.resolveProjectConfig();
        return projectJson.signupTargetLoginUrl;
    }
    catch {
        // a project isn't required for org:create
    }
};
//# sourceMappingURL=scratchOrgCreate.js.map