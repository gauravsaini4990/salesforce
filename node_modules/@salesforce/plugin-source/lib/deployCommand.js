"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getVersionMessage = exports.DeployCommand = void 0;
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const kit_1 = require("@salesforce/kit");
const sourceCommand_1 = require("./sourceCommand");
const stash_1 = require("./stash");
class DeployCommand extends sourceCommand_1.SourceCommand {
    constructor() {
        super(...arguments);
        this.displayDeployId = (0, kit_1.once)((id) => {
            if (!this.isJsonOutput()) {
                this.ux.log(`Deploy ID: ${id}`);
            }
        });
        this.isRest = false;
        this.isAsync = false;
        this.updateDeployId = (0, kit_1.once)((id) => {
            this.displayDeployId(id);
            const stashKey = stash_1.Stash.getKey(this.id);
            stash_1.Stash.set(stashKey, { jobid: id });
        });
    }
    /**
     * Request a report of an in-progress or completed deployment.
     *
     * @param id the Deploy ID of a deployment request
     * @returns DeployResult
     */
    async report(id) {
        const deployId = this.resolveDeployId(id);
        this.displayDeployId(deployId);
        const res = await this.org.getConnection().metadata.checkDeployStatus(deployId, true);
        const deployStatus = res;
        const componentSet = this.componentSet || new source_deploy_retrieve_1.ComponentSet();
        return new source_deploy_retrieve_1.DeployResult(deployStatus, componentSet);
    }
    /**
     * Checks the response status to determine whether the deploy was successful.
     * Async deploys are successful unless an error is thrown, which resolves as
     * unsuccessful in oclif.
     */
    resolveSuccess() {
        var _a, _b;
        const StatusCodeMap = new Map([
            [source_deploy_retrieve_1.RequestStatus.Succeeded, 0],
            [source_deploy_retrieve_1.RequestStatus.Canceled, 1],
            [source_deploy_retrieve_1.RequestStatus.Failed, 1],
            [source_deploy_retrieve_1.RequestStatus.SucceededPartial, 68],
            [source_deploy_retrieve_1.RequestStatus.InProgress, 69],
            [source_deploy_retrieve_1.RequestStatus.Pending, 69],
            [source_deploy_retrieve_1.RequestStatus.Canceling, 69],
        ]);
        if (!this.isAsync) {
            this.setExitCode((_b = StatusCodeMap.get((_a = this.deployResult.response) === null || _a === void 0 ? void 0 : _a.status)) !== null && _b !== void 0 ? _b : 1);
        }
    }
    /**
     * This method is here to provide a workaround to stubbing a constructor in the tests.
     *
     * @param id
     */
    createDeploy(id) {
        return new source_deploy_retrieve_1.MetadataApiDeploy({ usernameOrConnection: this.org.getUsername(), id });
    }
    resolveDeployId(id) {
        if (id) {
            return id;
        }
        else {
            const stash = stash_1.Stash.get(stash_1.Stash.getKey(this.id));
            if (!stash) {
                throw core_1.SfdxError.create('@salesforce/plugin-source', 'deploy', 'MissingDeployId');
            }
            return stash.jobid;
        }
    }
    // REST is the default unless:
    //   1. SOAP is specified with the soapdeploy flag on the command
    //   2. The restDeploy SFDX config setting is explicitly false.
    async isRestDeploy() {
        if ((0, ts_types_1.getBoolean)(this.flags, 'soapdeploy') === true) {
            this.logger.debug('soapdeploy flag === true.  Using SOAP');
            return false;
        }
        const aggregator = await core_1.ConfigAggregator.create();
        const restDeployConfig = aggregator.getPropertyValue('restDeploy');
        // aggregator property values are returned as strings
        if (restDeployConfig === 'false') {
            this.logger.debug('restDeploy SFDX config === false.  Using SOAP');
            return false;
        }
        else if (restDeployConfig === 'true') {
            this.logger.debug('restDeploy SFDX config === true.  Using REST');
            return true;
        }
        else {
            this.logger.debug('soapdeploy flag unset. restDeploy SFDX config unset.  Defaulting to SOAP');
        }
        return false;
    }
    async poll(deployId, options) {
        var _a, _b;
        const defaultOptions = {
            frequency: (_a = options === null || options === void 0 ? void 0 : options.frequency) !== null && _a !== void 0 ? _a : kit_1.Duration.seconds(1),
            timeout: (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : this.flags.wait,
            poll: async () => {
                const deployResult = await this.report(deployId);
                return {
                    completed: (0, ts_types_1.getBoolean)(deployResult, 'response.done'),
                    payload: deployResult,
                };
            },
        };
        const pollingOptions = { ...defaultOptions, ...options };
        const pollingClient = await core_1.PollingClient.create(pollingOptions);
        return pollingClient.subscribe();
    }
    async deployRecentValidation() {
        const id = this.getFlag('validateddeployrequestid');
        const response = await this.org.getConnection().deployRecentValidation({ id, rest: this.isRest });
        // This is the deploy ID of the deployRecentValidation response, not
        // the already validated deploy ID (i.e., validateddeployrequestid).
        // REST returns an object with an ID, SOAP returns the id as a string.
        const validatedDeployId = (0, ts_types_1.isString)(response) ? response : response.id;
        this.updateDeployId(validatedDeployId);
        this.asyncDeployResult = { id: validatedDeployId };
        return this.isAsync ? this.report(validatedDeployId) : this.poll(validatedDeployId);
    }
}
exports.DeployCommand = DeployCommand;
// the basic sfdx flag is already making sure its of the correct length
DeployCommand.isValidDeployId = (id) => {
    if (id.startsWith('0Af')) {
        return true;
    }
    else {
        throw core_1.SfdxError.create('@salesforce/plugin-source', 'deploy', 'invalidDeployId');
    }
};
const getVersionMessage = (action, componentSet, isRest) => {
    var _a;
    // commands pass in the.componentSet, which may not exist in some tests or mdapi deploys
    if (!componentSet) {
        return `*** ${action} with ${isRest ? 'REST' : 'SOAP'} ***`;
    }
    // neither
    if (!componentSet.sourceApiVersion && !componentSet.apiVersion) {
        return `*** ${action} with ${isRest ? 'REST' : 'SOAP'} ***`;
    }
    // either OR both match (SDR will use either)
    if (!componentSet.sourceApiVersion ||
        !componentSet.apiVersion ||
        componentSet.sourceApiVersion === componentSet.apiVersion) {
        return `*** ${action} with ${isRest ? 'REST' : 'SOAP'} API v${(_a = componentSet.apiVersion) !== null && _a !== void 0 ? _a : componentSet.sourceApiVersion} ***`;
    }
    // has both but they don't match
    return `*** ${action} v${componentSet.sourceApiVersion} metadata with ${isRest ? 'REST' : 'SOAP'} API v${componentSet.apiVersion} connection ***`;
};
exports.getVersionMessage = getVersionMessage;
//# sourceMappingURL=deployCommand.js.map